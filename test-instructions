🧰 1. Environment to Run the CGNAT PoC

A CGNAT program needs raw sockets / TUN/TAP interfaces and packet forwarding, which can’t run on most “simple online C compilers” because they lack network privileges.

✅ Recommended options:

Option	Environment	Advantages	Suitable for
Linux VM or bare metal	Ubuntu / Debian / Rocky Linux	Full root access, control over network stack	Full PoC
Cloud VM	Amazon Web Services, Google Cloud Platform, Microsoft Azure	Easily shareable, can create testbed with multiple IPs	Demos
Containers	Docker + network namespace + TUN/TAP	Lightweight, portable	Development
Network simulator	Mininet or GNS3	Easy topology building, ideal for labs	Showcasing

Minimum requirements for PoC

Linux OS with root privileges

GCC compiler (sudo apt install build-essential)

TUN/TAP enabled (/dev/net/tun present)

iptables or nftables installed (for routing setup)

2 or more interfaces (real or virtual)

🏗️ 2. Setting Up the Testbed

We’ll create:

One “LAN” network with many “customers” (simulated with private IPs: e.g., 10.0.0.0/24)

One “WAN” network with just 2–10 public IP addresses (e.g., 203.0.113.1–10)

A CGNAT node (your program) that maps LAN traffic → WAN public IPs + ports.

Simple topology
 [Client1:10.0.0.2]        [Client2:10.0.0.3]
         |                        |
         +--------- LAN ----------+
                     |
             [ CGNAT box ]
               |       |
           LAN iface   WAN iface (203.0.113.x pool)
               |
           Internet or test server

🧪 3. Installing & Building the PoC
# 1. Install dependencies
sudo apt update
sudo apt install build-essential iproute2 net-tools

# 2. Enable IP forwarding
sudo sysctl -w net.ipv4.ip_forward=1

# 3. Clone / Create cgnat.c
nano cgnat.c
# (Paste the C NAT example program you have)

# 4. Compile
gcc -o cgnat cgnat.c -lpthread

🔧 4. Network Emulation Using Linux Namespaces (Quick PoC)

You can simulate 20,000 clients without real devices. Example:

# Create network namespaces for 2 test clients and NAT
sudo ip netns add client1
sudo ip netns add client2
sudo ip netns add nat

# Create virtual ethernet pairs
sudo ip link add veth-c1 type veth peer name veth-nat1
sudo ip link add veth-c2 type veth peer name veth-nat2

# Attach to namespaces
sudo ip link set veth-c1 netns client1
sudo ip link set veth-c2 netns client2
sudo ip link set veth-nat1 netns nat
sudo ip link set veth-nat2 netns nat

# Assign IPs
sudo ip netns exec client1 ip addr add 10.0.0.2/24 dev veth-c1
sudo ip netns exec client1 ip link set veth-c1 up
sudo ip netns exec client1 ip route add default via 10.0.0.1

sudo ip netns exec client2 ip addr add 10.0.0.3/24 dev veth-c2
sudo ip netns exec client2 ip link set veth-c2 up
sudo ip netns exec client2 ip route add default via 10.0.0.1

sudo ip netns exec nat ip addr add 10.0.0.1/24 dev veth-nat1
sudo ip netns exec nat ip addr add 203.0.113.1/24 dev veth-nat2
sudo ip netns exec nat ip link set veth-nat1 up
sudo ip netns exec nat ip link set veth-nat2 up


Now, run your CGNAT program in the nat namespace:

sudo ip netns exec nat ./cgnat --lan veth-nat1 --wan veth-nat2 --public-pool 203.0.113.1-203.0.113.10

🧰 5. Testing the NAT Functionality

From the client namespaces, generate outbound traffic:

sudo ip netns exec client1 ping 8.8.8.8
sudo ip netns exec client2 curl http://example.com


Your CGNAT program should:

Intercept the packet

Map the source (e.g., 10.0.0.2:12345) → public (203.0.113.1:40001)

Forward to WAN

Reverse map on return traffic.

📝 Optional — use tcpdump to inspect NAT translations:

sudo ip netns exec nat tcpdump -i veth-nat2

🧾 6. Demonstrating to Customers / Stakeholders

For a customer demo, prepare:

Web dashboard / CLI showing NAT table in real time (e.g., 20,000 sessions mapped to 10 IPs)

Graph metrics: ports used, IP usage, active sessions

Test scenarios:

1,000 simulated connections using curl or iperf

Show how NAT allocates ports

Demonstrate timeouts and reuse

Optional: integrate a small web API to display NAT stats (e.g., expose metrics on localhost:8080)

You can even use iperf or wrk for load testing:

sudo ip netns exec client1 iperf -c 203.0.113.2 -t 60

📈 7. Scaling and Enhancing the PoC
Feature	Description	How to Add
Port pool management	Allocate blocks per client	Add per-subscriber table
Logging	Record NAT translations	File or SQLite backend
Load balancing	Distribute across 10 IPs	Round robin or hash
ALG support	Handle SIP, FTP, etc.	Parse L7 payload
IPv6 support	NAT64 / DS-Lite	Add IPv6 socket handling
GUI	Dashboard for customers	Lightweight web UI in C or Go frontend
🧪 8. Optional — Online & Cloud Demo Setup

If you want external customers to access the PoC:

Deploy your CGNAT PoC on a small VM (e.g., Amazon Web Services EC2 or Google Cloud Platform Compute Engine)

Assign a public IPv4 range (10 IPs)

Run CGNAT service

Spin up Docker containers inside the VM to simulate thousands of clients

Expose a web UI + metrics for remote viewing

🧠 Final Tips

Start with 100 clients, 1 WAN IP, then scale to 20,000 / 10 IPs.

Keep NAT state in a fast hash table (e.g., uthash in C).

Focus on performance of port allocation, efficient timeouts, and logging.

For production-grade, consider kernel-bypass (e.g., DPDK or PF_RING) — but PoC can use normal sockets.
